#ifndef _GNU_SOURCE
  #define _GNU_SOURCE
#endif

#include <iostream>
#include <ctime>
#include <cerrno>
#include <cassert>
#include <cstdint>
#include <cstdio>
#include <cstring>
#include <fcntl.h>
#include <stdlib.h>
#include <sched.h>
#include <unistd.h>
#include <math.h>
#include <climits>
#include <signal.h>
#include <vector>
#include <sys/mman.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <asm/unistd.h>
#ifndef __ANDROID__
#include "ptedit_header.h"
#endif

#include "utils.h"


int g_pagemap;
int g_mem_fd;

// bit position of row address in physical address
const int sort_rows_shift = 15;

uint64_t CACHE_MISS = 478;

unsigned char throttle[1] = {1};


#ifdef __ANDROID__
const char *pipe_path = "%s/%s";
const char *pipe_in_file = "pipe_root_helper_in";    // write to here
const char *pipe_out_file = "pipe_root_helper_out";  // read from here
FILE *pipe_in_fd = NULL;
FILE *pipe_out_fd = NULL;
#endif



void setcpu(int cpu) {
	cpu_set_t set;
	struct sched_param sched_param = {};

	CPU_ZERO(&set);
	CPU_SET(cpu, &set);
	if (sched_setaffinity(getpid(), sizeof(set), &set) == -1) {
    printf("sched_setaffinity failed\n");
    exit(1);
  }
  if (0) {
		sched_param.sched_priority = 0;
		if (sched_setscheduler(getpid(), SCHED_FIFO, &sched_param))
      printf("sched_setscheduler failed\n");
      exit(1);
	}
}





int open_page_map() {
  g_pagemap = open("/proc/self/pagemap", O_RDONLY | O_CLOEXEC);
  if (g_pagemap == -1) {
    std::cout << "opening pagemap failed " << errno << " " << strerror(errno)
              << ", exiting" << std::endl;
    return -1;
  }
  printf("opened pagemap\n");
  return 0;
}


uint64_t get_ppn(uintptr_t virtual_address) {
  uint64_t page_frame_number;
#ifndef __ANDROID__
  uint64_t value;
  // Read the entry in the pagemap.
  int got = pread(g_pagemap, &value, 8,
                  virtual_address / 0x1000 * 8);
  if (got != 8) {
  	printf("didn't read 8 bytes from pagemap\n");
  	exit(255);
  }
  page_frame_number = value & ((1ULL << 54)-1);
#else
  fprintf(pipe_in_fd, "pagemap %lx\n", virtual_address);
  if (fscanf(pipe_out_fd, "%lx", &page_frame_number) == EOF) {
    return -1;
  }
#endif
  return page_frame_number;
}



void init_dev_mem() {
  int rc;
  g_mem_fd = open("/dev/mem", O_RDWR | O_SYNC);
  assert(g_mem_fd >= 0);

  // Check that /dev/mem works.
  int *mem = (int *) mmap(NULL, 0x1000, PROT_READ | PROT_WRITE,
                          MAP_PRIVATE | MAP_ANON | MAP_POPULATE, -1, 0);
  assert(mem != (int *) MAP_FAILED);
  for (int i = 0; i < 10; i++) {
    *mem = i;
    int val = 0;
    int got = pread(g_mem_fd, &val, sizeof(val),
                    get_ppn((uintptr_t) mem) * 0x1000);
    assert(got == sizeof(val));
    assert(val == i);
  }
  rc = munmap(mem, 0x1000);
  assert(rc == 0);
}


uint64_t read_physical_mem(uint64_t paddr) {
  uint64_t val = 0;
  //printf("%ld\n", paddr);
  int got = pread(g_mem_fd, &val, sizeof(val), paddr);
  if (got != sizeof(val)) {
    //printf("%d %ld %lx %d %d %s\n", g_mem_fd, paddr, val, got, errno, strerror(errno));
  }
  //assert(got == sizeof(val));
  return val;
}


uint64_t write_physical_mem(uint64_t paddr, uint64_t val) {
  int wrote = pwrite(g_mem_fd, &val, sizeof(val), paddr);
  //printf("wrote to physical mem %d %ld\n", wrote, sizeof(val));
  assert(wrote == sizeof(val));
  return val;
}


uint64_t flip_bit(uint64_t paddr, int test_bit_to_flip) {
  printf("Test mode: Flipping bit at address %llx...\n",
         (long long) paddr);
  uint64_t val;
  int got = pread(g_mem_fd, &val, sizeof(val), paddr);
  assert(got == sizeof(val));
  printf("  before:  val=0x%llx\n", (long long) val);

  val ^= 1ULL << test_bit_to_flip;
  printf("  after:   val=0x%llx\n", (long long) val);
  printf("  Changed bit %i to %i\n",
         test_bit_to_flip, (int) ((val >> test_bit_to_flip) & 1));
  int written = pwrite(g_mem_fd, &val, sizeof(val), paddr);
  assert(written == sizeof(val));
  return val;
}




#ifdef __ANDROID__
int open_root_helper_pipes(char *cacheDirPath) {
  char buf[512];
  int ret;

  printf("open_root_helper_pipes %s\n", cacheDirPath);

  snprintf(buf, sizeof(buf), pipe_path, cacheDirPath, pipe_in_file);
  if (access(buf, F_OK) != 0) {
    mkfifo(buf, 0666);
  }
  pipe_in_fd = fopen(buf, "r+");
  if (pipe_in_fd == NULL)
    return -1;

  snprintf(buf, sizeof(buf), pipe_path, cacheDirPath, pipe_out_file);
  if (access(buf, F_OK) != 0) {
    mkfifo(buf, 0666);
  }
  pipe_out_fd = fopen(buf, "r+");
  if (pipe_out_fd == NULL)
    return -1;

  setbuf(pipe_in_fd, NULL);
  setbuf(pipe_out_fd, NULL);

  fprintf(pipe_in_fd, "open_pagemap %x\n", getpid());
  if (fscanf(pipe_out_fd, "%d", &ret) == EOF) {
    return -1;
  }

  printf("open_pagemap returned %d\n", ret);

  return 0;
}
#endif



static long perf_event_open(struct perf_event_attr *hw_event, pid_t pid,
                            int cpu, int group_fd, unsigned long flags)
{
  int ret;
  ret = syscall(__NR_perf_event_open, hw_event, pid, cpu, group_fd, flags);
  return ret;
}




int make_uncacheable(uint8_t *mem, size_t mem_size, int level) {
#ifndef FLUSH
#ifdef __ANDROID__
  int tmp;
  fprintf(pipe_in_fd, "uncacheable %d\n%lx %lx\n", level, (uint64_t) mem, mem_size);
  if (fscanf(pipe_out_fd, "%d", &tmp) == EOF) {
    return -1;
  }
#else 
  int uc_mt = ptedit_find_first_mt(PTEDIT_MT_UC);
  if (uc_mt == -1)   {
    std::cout << "No memory uncachable memory type attribute" << std::endl;
		exit(255);
  }

  // Mark uncacheable
  uint64_t i;
  if (level == 0) {
    for (i = 0; i < mem_size; i += 0x1000) {
      ptedit_entry_t entry = ptedit_resolve(mem + i, 0);
      entry.pte = ptedit_apply_mt(entry.pte, uc_mt);
      entry.valid = PTEDIT_VALID_MASK_PTE;
      ptedit_update(mem + i, 0, &entry);
    }
  }
  else if (level == 1) {
    for (i = 0; i < mem_size; i += 0x200000) {
      ptedit_entry_t entry = ptedit_resolve(mem + i, 0);
      entry.pmd = ptedit_apply_mt(entry.pmd, uc_mt);
      entry.valid = PTEDIT_VALID_MASK_PMD;
      ptedit_update(mem + i, 0, &entry);
    }
  }
#endif
#endif
  return 0;
}




void grep(const char* path, const char* pattern) {
  FILE *fp;
  char *line = NULL;
  size_t len = 0;
  ssize_t read;

  fp = fopen(path, "r");
  if (fp == NULL)
    return;

  while ((read = getline(&line, &len, fp)) != -1) {
    if(pattern == NULL || strncmp(line, pattern, strlen(pattern)) == 0)
      printf("%s", line);
  }

  fclose(fp);
  free(line);
}


void cat(const char* path) {
  grep(path, NULL);
}


size_t get_free_mem() {
  struct sysinfo info;
  
  if (sysinfo(&info) < 0)
    return 0;
    
  return info.freeram;
}



int match_pattern(int *p1, int length, std::vector<int> p2, int test_length = 0) {
  int offset;
  int matches;

  if (test_length == 0 || test_length > length)
    test_length = length;

  if (length > p2.size())
    return 0;

  for (offset = 0; offset < p2.size(); offset++) {

    //printf("offset: %d\n", offset);

    for (int j = 0; j <= length - test_length; j++) {
      matches = 1;

      for (int i = 0; i < test_length; i++) {
        //printf("%d ", p1[i]);
        if (p1[i + j] != p2[(offset + i) % p2.size()]) {
          matches = 0;
          break;
        }
      }
      
      if (matches) {
        return 1;
      }
    }
    //printf("\n");
    //for (int i = 0; i < length; i++) {
    //  printf("%d ", p2[(offset + i) % p2.size()]);
    //}
    //printf("\n");
  }

  return 0;
}



#ifdef USE_VFORK
/* Returns zero if address is safe to access                                    
 * The vforked child shares the page tables with the parent process.            
 * It is able to dereference the pointer on the parent's behalf.  Should        
 * the page tables that are backing that pointer be corrupted, there            
 * will be a data abort exception, which the kernel will handle by              
 * killing the child process.  The parent can look at the cause of death        
 * to determine if the address was dereferenced successfully.  By doing          
 * so,the parent can avoid dereferencing addresses that are backed by            
 * unusable page table entries.            
 * 
 * value can be != nullptr and should be a pointer to a shared memory page                                      
 */
int check_address(volatile uint64_t *address)                              
{                                                                                
  int status;                                                              
  int pid = vfork();                                                      
  if (!pid) {                                                              
    /* Child process */                                              
    flush((void*) address);
    *address;
    _exit(0);
  }                                                                        
  /* Parent process resumes */                                            
  wait(&status);                                                          
                                                                            
  if (WIFSIGNALED(status)) {                                              
    printf("Canary died dereferencing address: %p\n", address);                        
    return 1;                                                        
  }                                                                        
                                                                            
  return 0;                                                                
}

int check_address_range(volatile uint64_t *address, size_t size)
{
  int status;
  int pid = vfork();
  if (!pid) {
    for (int i = 0; i < size / sizeof(uint64_t); i += 0x1000 / sizeof(uint64_t)) {
      /* Child process */
      flush((void*) (address + i));
      address[i];
    }
    _exit(0);
  }
  /* Parent process resumes */
  wait(&status);
  
  if (WIFSIGNALED(status)) {
    printf("Canary died dereferencing address: %p\n", address);
    return 1;
  }
  
  return 0;
}
#else
int is_cached(volatile char *address) {
  uint64_t start, end;
  start = ns();
  *address;
  end = ns();
  return (end - start < CACHE_MISS);
}


void access_array(volatile char *mem, char* mydata, char* mydata2, char* mydata3, char* mydata4, char* mydata5, int run) {
  flush(&run);

  if (((run) / throttle[0]) > (1.0) / throttle[0]) {
     *(mem + (mydata[0] & 1) + (mydata2[0] & 1) + (mydata3[0] & 1) + (mydata4[0] & 1) + (mydata5[0] & 1));
  }
}


void access_array_1(volatile char *mem, char* mydata, int run) {
  flush(&run);

  if (((run) / throttle[0]) > (1.0) / throttle[0]) {
     *(mem + (*mydata & 1));
  }
}


int measure(char* buffer, char* address, char* address2, char* address3, char* address4, char* address5)
{
  for (int j = 0; j < 1; j++) {
    /* Moar magic */
    for (volatile int u = 0; u < 50; u++) {
      asm volatile ("nop");
    }

    /* Mistrain */
    for (int y = 0; y < 100; y++) {
      access_array(buffer, buffer, buffer, buffer, buffer, buffer, 2);
    }

    flush(buffer);
    asm volatile("DSB ISH");

    access_array(buffer, address, address2, address3, address4, address5, 1);

    if (is_cached(buffer)) {
      return 0;
    }
  }

  return 1;
}


int measure_1(char* buffer, char* address)
{
  /* Mistrain */
  for (int y = 0; y < 50; y++) {
    access_array_1(buffer, buffer, 2);
  }

  for (int j = 0; j < 5; j++) {
    /* Moar magic */
    for (volatile int u = 0; u < 50; u++) {
      asm volatile ("nop");
    }

    /* Mistrain */
    for (int y = 0; y < 10; y++) {
      access_array_1(buffer, buffer, 2);
    }

    flush(buffer);
    asm volatile("DSB ISH");

    access_array_1(buffer, address, 1);

    if (is_cached(buffer)) {
      return 0;
    }
  }

  return 1;
}


int check_address(volatile uint64_t *address)
{
  return check_address_range(address, 1);
}


int check_address_range(volatile uint64_t *address, size_t size)
{
  char buffer[8];
  char dummy;

  if (size > 0x5000) {
    printf("check_address_range cannot check more than 5 addresses!\n");
    return 1;
  }

  switch (size) {
    case 0x1000:
      return measure_1(buffer, (char*) address);
    case 0x5000:
      return measure(buffer, (char*) address, ((char*) address) + 0x1000, 
                     ((char*) address) + 0x2000, ((char*) address) + 0x3000, 
                     ((char*) address) + 0x4000);
  }

  return 1;
}
#endif


void print_ppn_distribution(volatile uint8_t *mem, size_t mem_size) {
  for (int k = 0; k < 3; k++) {
    for (int i = 0; i < 30; i++) {
      int low = 0, mid = 0, high = 0;

      for (size_t j = (mem_size / 30) * i; 
          j < (mem_size / 30) * (i + 1); 
          j += 0x200000) {

        int ppn = get_ppn((uintptr_t) mem + j);
        if (ppn < 0x70000) {
          low++;
        }
        else if (ppn < 0x100000) {
          mid++;
        }
        else {
          high++;
        }
      }

      if (k == 0) {
        printf("%3d ", (int) round(100.f * low / (low + mid + high)));
      }
      else if (k == 1) {
        printf("%3d ", (int) round(100.f * mid / (low + mid + high)));
      }
      else {
        printf("%3d ", (int) round(100.f * high / (low + mid + high)));
      }
    }
    printf("\n");
  }
  fflush(stdout);
}



void print_ppn_distribution(std::vector<std::vector<uint8_t*>> rows_vector) {
  std::vector<uint8_t*> all_rows;

  for (auto rows : rows_vector) {
    for (int i = 0; i < rows.size(); i++) {
      if ((i - 2) % 3 == 0) {
        continue;
      }
      all_rows.push_back(rows[i]);
    }
  }

  for (int k = 0; k < 3; k++) {
    for (int i = 0; i < 30; i++) {
      int low = 0, mid = 0, high = 0;

      for (size_t j = (all_rows.size() / 30) * i; 
          j < (all_rows.size() / 30) * (i + 1); 
          j += 0x200000) {

        int ppn = get_ppn((uintptr_t) all_rows[j]);
        if (ppn < 0x70000) {
          low++;
        }
        else if (ppn < 0x100000) {
          mid++;
        }
        else {
          high++;
        }
      }

      if (k == 0) {
        printf("%3d ", (int) round(100.f * low / (low + mid + high)));
      }
      else if (k == 1) {
        printf("%3d ", (int) round(100.f * mid / (low + mid + high)));
      }
      else {
        printf("%3d ", (int) round(100.f * high / (low + mid + high)));
      }
    }
    printf("\n");
  }
  fflush(stdout);
}





int get_row_number(uintptr_t addr, int limit) {
  if (limit == 0) {
    limit = ~0;
  }

                  // cut of bits higher than our 2mb page
	uintptr_t row = (addr >> sort_rows_shift) & limit;
	uintptr_t bit3 = (row & (1 << 3)) >> 3;

	/* "Defeating Software Mitigations against Rowhammer: a Surgical
	 *  Precision Hammer".  Section 3.1, Sub-heading : Remapping.
	 */
	row = row ^ (bit3 << 2);
	row = row ^ (bit3 << 1);
	return row;
}


void print_addressing_bits(uintptr_t addr) {
  printf("%ld %ld %ld",
    ((addr >> 12) ^ (addr >> 16)) & 1,
    ((addr >> 13) ^ (addr >> 17)) & 1,
    ((addr >> 14) ^ (addr >> 18)) & 1);
}


int get_addressing_bits(uintptr_t addr) {
  return (int) (((addr >> 8) & 1) |
         (((addr >> 12) ^ (addr >> 16)) & 1) << 1 |
         (((addr >> 13) ^ (addr >> 17)) & 1) << 2 |
         (((addr >> 14) ^ (addr >> 18)) & 1) << 3);
}


uintptr_t get_prev_row(uintptr_t addr) {
  int row_number = get_row_number(addr);
  int addressing_bits = get_addressing_bits(addr);

  if (row_number == 0)
    return 0;

  for (int i = 0; i < 10000; i++) {
    if (get_addressing_bits(addr - i * 0x1000) == addressing_bits && 
        get_row_number(addr - i * 0x1000) == row_number - 1) {
      return addr - i * 0x1000;
    }
    if (get_addressing_bits(addr + i * 0x1000) == addressing_bits && 
        get_row_number(addr + i * 0x1000) == row_number - 1) {
      return addr + i * 0x1000;
    }
  }

  return 0;
}


uintptr_t get_next_row(uintptr_t addr) {
  int row_number = get_row_number(addr);
  int addressing_bits = get_addressing_bits(addr);

  if (row_number == 63)
    return 0;

  for (int i = 0; i < 10000; i++) {
    if (get_addressing_bits(addr - i * 0x1000) == addressing_bits && 
        get_row_number(addr - i * 0x1000) == row_number + 1) {
      return addr - i * 0x1000;
    }
    if (get_addressing_bits(addr + i * 0x1000) == addressing_bits && 
        get_row_number(addr + i * 0x1000) == row_number + 1) {
      return addr + i * 0x1000;
    }
  }

  return 0;
}



void *aligned_mmap(size_t alignment, size_t length, int prot, int flags,
                  int fd, off_t offset) {
  void *addr;

  do {
    // get a 4k page aligned address from the kernel that fits 
    // length + alignment. The address we get here is used the calculate the
    // aligned address we will use for the next mmap call
    addr = mmap(NULL, length + alignment, prot, flags, fd, offset);
    
    if (addr == MAP_FAILED)
      return MAP_FAILED;

    printf("address: %p\n", addr);

    // unmap the memory
    munmap(addr, length + alignment);

    // if another thread (that does not exist at the moment) now maps memory
    // to exactly that address the mmap will fail. Because of that we run this
    // thing in a loop. #hackerman

    // align the address
    void *aligned_addr = (void*) 
                            (((uintptr_t) addr & ~(alignment - 1)) + alignment);

    printf("aligned address: %p\n", aligned_addr);

    // mmap aligned
    addr = mmap(aligned_addr, length, prot, flags | MAP_FIXED, fd, offset);

    printf("got address: %p %lx\n", addr, (uintptr_t) addr % alignment);

    if (addr == MAP_FAILED)
      return MAP_FAILED;

  } while(((uintptr_t) addr % alignment) != 0);
  
  return addr;
}


volatile uint8_t *get_aligned_uncached_mem(size_t mem_size) {
  // get the memory
  volatile uint8_t *mem = (volatile uint8_t*) aligned_mmap(0x200000, mem_size, 
    PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  
  if ((void*) mem == MAP_FAILED) {
    std::cout << "aligned_mmap failed " << errno << " " << strerror(errno)
              << ", exiting" << std::endl;
    return (volatile uint8_t *) -1;
  }
  printf("got memory %p\n", mem);

#ifdef USE_HUGEPAGES
  // tell the kernel that we would like to have huge pages (if you change this, change make_uncacheable level below)
  int ret = madvise((void*) mem, mem_size, MADV_HUGEPAGE | MADV_DONTFORK);
  if(ret != 0) {
    std::cout << "madvise failed " << errno << " " << strerror(errno)
              << ", exiting" << std::endl;
    return (volatile uint8_t *) -1;
  }
  printf("advised hugepage\n");
#endif

  // map the pages
  for(size_t i = 0; i < mem_size; i += 0x1000) {
    mem[i] = 1;
  }

#ifdef USE_HUGEPAGES
  // split up huge pages
  for(size_t i = 0x200000 - 0x1000; i < mem_size; i += 0x200000) {
    munmap((void*) (mem + i), 0x1000);
  }
#endif

  // make them uncachable
  make_uncacheable((uint8_t*) mem, mem_size, 0);
  make_uncacheable((uint8_t*) mem, mem_size, 1);

  printf("mapped all pages %ld\n", get_free_mem());

  return mem;
}


#ifndef __ANDROID__
uintptr_t get_pmd_pfn(void *addr) {
  ptedit_entry_t entry = ptedit_resolve(addr, 0);
  return ptedit_cast(entry.pmd, ptedit_pmd_t).pfn;
}
#endif