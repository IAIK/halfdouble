#ifndef UTIL_H
#define UTIL_H

#include <vector>
#include "globals.h"

// colored outputs
#ifndef __ANDROID__
#define COLOR_RED "\x1b[31m"
#define COLOR_GREEN "\x1b[32m"
#define COLOR_YELLOW "\x1b[33m"
#define COLOR_CYAN "\x1b[36m"
#define COLOR_BLUE "\x1b[34m"
#define COLOR_MAGENTA "\x1b[35m"
#define COLOR_RESET "\x1b[0m"
#else
#define COLOR_RED ""
#define COLOR_GREEN ""
#define COLOR_YELLOW ""
#define COLOR_CYAN ""
#define COLOR_BLUE ""
#define COLOR_MAGENTA ""
#define COLOR_RESET ""
#endif


#define NOP() asm volatile("NOP");
#define NOP10() NOP() NOP() NOP() NOP() NOP() NOP() NOP() NOP() NOP() NOP()
#define NOP100() NOP10() NOP10() NOP10() NOP10() NOP10() NOP10() NOP10() NOP10() NOP10() NOP10() 
#define NOP1000() NOP100() NOP100() NOP100() NOP100() NOP100() NOP100() NOP100() NOP100() NOP100() NOP100() 


extern FILE *pipe_in_fd;
extern FILE *pipe_out_fd;



inline void flush(void *addr) {
  asm volatile("dc civac, %0\n\t" : : "r" (addr) : "memory");
}

inline void isb() {
  asm volatile("isb");
}

inline void dmb() {
  asm volatile("dmb ishld");
}

inline void dsb() {
  asm volatile("dsb ish");
}

inline uint64_t ns() {
  struct timespec tp;
  clock_gettime(CLOCK_MONOTONIC, &tp);
  return ((uint64_t) tp.tv_sec) * 1000000000ULL + tp.tv_nsec;
}

// inline uint64_t ns() {
//   uint64_t value;
//   asm volatile("isb ; mrs %0, cntvct_el0 ; isb" : "=r" (value) :: "memory");
//   return value;
// }


void setcpu(int cpu);

int open_page_map();
uint64_t get_ppn(uintptr_t virtual_address);

void init_dev_mem();
uint64_t read_physical_mem(uint64_t paddr);
uint64_t write_physical_mem(uint64_t paddr, uint64_t val);
uint64_t flip_bit(uint64_t paddr, int test_bit_to_flip);

#ifdef __ANDROID__
int open_root_helper_pipes(char *cacheDirPath);
#endif


static long perf_event_open(struct perf_event_attr *hw_event, pid_t pid,
                            int cpu, int group_fd, unsigned long flags);

int make_uncacheable(uint8_t *mem, size_t mem_size, int level);

void grep(const char* path, const char* pattern);
void cat(const char* path);

size_t get_free_mem();

int match_pattern(int *p1, int length, std::vector<int> p2, int test_length);

/* Returns zero if address is safe to access                                    
 * The vforked child shares the page tables with the parent process.            
 * It is able to dereference the pointer on the parent's behalf.  Should        
 * the page tables that are backing that pointer be corrupted, there            
 * will be a data abort exception, which the kernel will handle by              
 * killing the child process.  The parent can look at the cause of death        
 * to determine if the address was dereferenced successfully.  By doing          
 * so,the parent can avoid dereferencing addresses that are backed by            
 * unusable page table entries.            
 * 
 * value can be != nullptr and should be a pointer to a shared memory page                                      
 */
int check_address(volatile uint64_t *address);
int check_address_range(volatile uint64_t *address, size_t size);

void print_ppn_distribution(volatile uint8_t *mem, size_t mem_size);
void print_ppn_distribution(std::vector<std::vector<uint8_t*>> rows_vector);

int get_row_number(uintptr_t addr, int limit = 0x3f);
void print_addressing_bits(uintptr_t addr);
int get_addressing_bits(uintptr_t addr);
uintptr_t get_prev_row(uintptr_t addr);
uintptr_t get_next_row(uintptr_t addr);


uintptr_t get_pmd_pfn(void *addr);

int ptedit_init();



#endif //UTIL_H